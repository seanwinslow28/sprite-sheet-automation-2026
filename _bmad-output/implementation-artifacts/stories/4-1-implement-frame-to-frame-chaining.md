# Story 4.1: Implement Frame-to-Frame Chaining (Edit-from-Previous)

Status: done

---

## Story

**As an** operator,
**I want** frames 2+ generated by editing from the previous approved frame,
**So that** animation sequences maintain temporal consistency.

---

## Acceptance Criteria

### Frame Chaining Logic

1. **Edit-from-anchor for Frame 0** - Frame 0 uses anchor as edit base (established in Story 2.3)
2. **Edit-from-previous for Frame 1+** - Adapter uses previous approved frame as edit base
3. **Variation prompt** - Applies `generator.prompts.variation` with frame index interpolation
4. **Chaining decision logged** - System logs whether chaining from anchor or previous frame
5. **Re-anchor on drift** - If identity drift detected, system can re-anchor to original anchor image

### State Management

6. **Approved frame tracking** - System tracks path to most recently approved frame
7. **Frame sequence** - Approved frames stored in order for retrieval
8. **Chain break handling** - On failure, system knows to fall back to anchor

---

## Tasks / Subtasks

- [x] **Task 1: Extend Generator Adapter for chaining** (AC: #1, #2)
  - [x] 1.1: Add `previousApprovedFrame?: string` to `GenerateFrameParams`
  - [x] 1.2: Modify `generateFrame()` to accept optional previous frame path
  - [x] 1.3: When `frameIndex === 0`, always use anchor as edit base
  - [x] 1.4: When `frameIndex > 0` and previous frame exists, use previous frame

- [x] **Task 2: Implement frame reference selection** (AC: #2, #5)
  - [x] 2.1: Create `selectReferenceFrame(frameIndex: number, state: RunState): string`
  - [x] 2.2: Return anchor path for Frame 0
  - [x] 2.3: Return previous approved frame path for Frame N > 0
  - [x] 2.4: If previous frame doesn't exist (gap), fall back to anchor

- [x] **Task 3: Update Semantic Interleaving for chaining** (AC: #2)
  - [x] 3.1: Modify `Part[]` construction in generator adapter
  - [x] 3.2: [IMAGE 2] uses previous frame (not anchor) when chaining
  - [x] 3.3: Maintain hierarchy: "[IMAGE 1] (Anchor) wins over [IMAGE 2] (Previous)"
  - [x] 3.4: Log which reference strategy is being used

- [x] **Task 4: Implement prompt template selection** (AC: #3)
  - [x] 4.1: Frame 0: Use `generator.prompts.master`
  - [x] 4.2: Frame 1+: Use `generator.prompts.variation`
  - [x] 4.3: Interpolate `{frame_index}` and `{total_frames}` in variation prompt
  - [x] 4.4: Include frame position context: "Frame 3 of 8"

- [x] **Task 5: Implement chaining state tracking** (AC: #6, #7)
  - [x] 5.1: Track `approved_frames: string[]` in `state.json`
  - [x] 5.2: After approval, add frame path to approved list
  - [x] 5.3: Provide getter: `getApprovedFrame(frameIndex: number): string | undefined`
  - [x] 5.4: Handle gaps in approved sequence

- [x] **Task 6: Implement logging for chain decisions** (AC: #4)
  - [x] 6.1: Log "Frame N: Chaining from previous approved frame"
  - [x] 6.2: Log "Frame 0: Using anchor as edit base"
  - [x] 6.3: Log "Frame N: Re-anchoring due to drift/gap"
  - [x] 6.4: Include paths in structured log

- [x] **Task 7: Implement re-anchor fallback** (AC: #5, #8)
  - [x] 7.1: Accept `forceReAnchor: boolean` parameter
  - [x] 7.2: When true, skip previous frame and use anchor
  - [x] 7.3: Log reason for re-anchor decision
  - [x] 7.4: Integrate with retry ladder (Story 4.3)

- [x] **Task 8: Write tests** (AC: all)
  - [x] 8.1: Test Frame 0 always uses anchor
  - [x] 8.2: Test Frame 1 uses Frame 0's approved path
  - [x] 8.3: Test Frame N uses Frame N-1's approved path
  - [x] 8.4: Test fallback when previous frame missing
  - [x] 8.5: Test force re-anchor overrides chaining

---

## Dev Notes

### Chaining Flow

```
Frame 0: Anchor → Generator → Audit → Approve → approved_frames[0]
Frame 1: approved_frames[0] → Generator → Audit → Approve → approved_frames[1]
Frame 2: approved_frames[1] → Generator → Audit → Approve → approved_frames[2]
...
```

### Reference Frame Selection Logic

```typescript
function selectReferenceFrame(
  frameIndex: number,
  approvedFrames: string[],
  anchorPath: string,
  forceReAnchor: boolean = false
): { path: string; source: 'anchor' | 'previous' } {
  // Frame 0 always uses anchor
  if (frameIndex === 0) {
    return { path: anchorPath, source: 'anchor' };
  }

  // Force re-anchor (drift recovery)
  if (forceReAnchor) {
    return { path: anchorPath, source: 'anchor' };
  }

  // Try to use previous approved frame
  const previousFrame = approvedFrames[frameIndex - 1];
  if (previousFrame) {
    return { path: previousFrame, source: 'previous' };
  }

  // Fallback to anchor if previous doesn't exist
  return { path: anchorPath, source: 'anchor' };
}
```

### State.json Approved Frames

```json
{
  "approved_frames": [
    "runs/abc123/approved/frame_0000.png",
    "runs/abc123/approved/frame_0001.png",
    "runs/abc123/approved/frame_0002.png"
  ],
  "current_frame_index": 3,
  "chain_breaks": [
    { "frame": 5, "reason": "SF01_IDENTITY_DRIFT", "action": "re_anchor" }
  ]
}
```

### Integration with Semantic Interleaving (Story 2.3)

When constructing `Part[]` array:
- **[IMAGE 1]**: Always the Anchor (identity truth)
- **[IMAGE 2]**: Previous approved frame (if chaining) OR omitted (if re-anchoring)

### Performance Considerations

- Previous frame path lookup is O(1) from array
- No additional file I/O until generation (adapter loads images)
- State updates are atomic (existing pattern)

### Project Structure Notes

- Modify: `src/adapters/gemini-generator-adapter.ts`
- Modify: `src/core/state-manager.ts` (add approved_frames tracking)
- New helper: `src/core/frame-chain-resolver.ts`
- Tests: `test/core/frame-chain-resolver.test.ts`

### References

- [Source: _bmad-output/planning-artifacts/epics.md#Story 4.1]
- [Source: _bmad-output/project-context.md#Semantic Interleaving]
- [Source: stories/2-3-implement-gemini-generator-adapter-semantic-interleaving.md]

---

## Dev Agent Record

### Agent Model Used

**Codex-CLI**

**Rationale:** Chaining logic (use previous approved frame) follows a clear decision flow. Well-defined state tracking with deterministic behavior. No complex architectural decisions—straightforward extension of existing adapter.

### Debug Log References

N/A - Implementation tested via unit tests.

### Completion Notes List

- Implemented frame reference selection with anchor fallback
- Added support for force re-anchor on drift recovery
- Integrated with retry ladder for automatic re-anchor decisions
- All 17 tests passing

### File List

- `src/core/frame-chain-resolver.ts` - Frame chaining logic (172 lines)
- `test/core/frame-chain-resolver.test.ts` - Unit tests (17 tests)
